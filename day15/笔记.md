函数的执行结果return多少就是多少，没有return就是undefined
## this关键字
1）在全局作用域下，this就是window。
2）函数执行的时候，看前面有没有点，如果有点，前面是谁，函数执行的时候，里面this就是谁，如果没有带你，里面的this就是window(非严格模式)，在严格模式下(undefined)
~~~
//"use strict"
function fn() {
    console.log(this);
}
var obj={
    "name":"li",
    fn:fn
}
// obj.fn();
fn();
~~~
3)给元素绑定事件的时候，当事件触发，函数执行的时候,里面的this就是当前绑定的元素
~~~
ele.onclick=function () {
}
~~~
4)自执行函数中的this
非严格模式下:window
严格模式下:undefined
~~~
;(function () {
    console.log(this);
})();
~~~
5)回调函数函数里面的this是window
~~~
setTimeout(function()  {
    console.log(this);
}, 1000);
~~~
~~~
function fn(callback) {
    console.log("下午好");
    callback()
    
}
fn(function () {
})
~~~
6）通过类创造的实例，构造函数中的this指的就是当前的实例
~~~
function fn() {
    this.x=100;
    this.name-"li"
}
var f1=new fn();
~~~
7)通过call,apply,bind可以更改this的指向
~~~
function fn() {
    console.log(this);
}
var obj={
    name:"li",
    fn:fn
}
//fn
fn.call(obj)
~~~
8)箭头函数里没有this，也没有arguments，但是在箭头函数里用this，会向上级作用域寻找。
##  高级单例模式
~~~
var utils=(function () {
    var num=3;
    function fn( {
        
    }
    return{
        //初始化
        init：function()
    {
        getDate();
        bindHTML(绑定元素)
    }
        num:num
        fn:fn
    }
})();
~~~
##  工厂设计模式（函数封装）
~~~
function person(name,age,sex){
    return{
        job:"前端开发工程师“,
        name:name
        age:age
        sex:sex

    }
}
var p1=person("wangzhe",18,"女“)；
var p2=person("wangzhe",20,"女“)；
~~~
## 构造函数：
在构造函数中，通过this添加的属性名和属性值都是添加给了当前的实例（构造函数中的this就是当前的实例）
当函数执行的时候，前面一旦加了new，就变成了构造函数（类），
如果构造函数没有形参，在调用的时候可以直接省去（）//var f1=new fn
f1，f2就变成实例，实例是对象数据类型，实例和实例是不相等的，（空间地址不同）
构造函数中this添加的属性是私有的。记得，就是当前的实例，如果你手动去更改
如果return基本数据类型，或只写了return，不能覆盖
如果return引用数据类型，直接覆盖，就变成你的这个了
<!-- 注意：在构造函数中少用return -->
在构造函数中：return是mo ren fan h
内置类：Number String Boolean Null Undefined  RegExp(正则)      Function Object Math
~~~
function Fn（fn的F一般大写）(name，ages){
    this.name=name;
    this.age=age;
}
var f1=new Fn();一个函数在执行的时候，一旦加了new，这个函数就变成了构造函数，f1就是实例。
var f2=new Fn();
console log(f1,f2)
~~~
构造数组的俩种方式：
1.构造函数（类）,通过此方式进行创建的时候，；
+ 参数：1个的时候代表的是数组的长度
+ 参数>1,代表的是数组的每项
2.字面量的方式
~~~
var f1=new Array(1,2,3);//[1,2,3];
var f1=[5];//创建了一个数组长度是5项的数组，但每项是空内容
var f2=[4，5，6];
~~~
##  instanceof 主要用来判断某个实例是否隶属于某个类，返回结果是布尔数据类型，
语法：实例 instanceof 类
比如：[1，2，3] instanceof Array
## in 某个对象，是否拥有某个属性，无论是公有还是私有的，返回值就是true，无就是false。
语法+属性名 in 对象
例子：“age” in f
## hasOwnProperty:主要用来检测某个属性是不是对象私有的，如果是私有的就是true，如果没有，或者没有这个属性，否则就是false
语法 对象.hasOwnProperty（"属性名"）
例子：f1.hasOwnProperty("age")
~~~
function fn(){
    this.age=18;
    this.name="li"
}
f1.hasOwnProperty("age")
~~~
~~~
封装一个属性是不是共有的
function hasOwnpublicProperty(obj,attr) {
     if ((isNaN(attr in obj)==-1) {
         if(!obj.hasOwnProperty(attr)) {
             return true
         }
     }
     return false
 }
function hasOwnpublicProperty(obj, attr) {
    return attr in obj&&!obj.hasOwnProperty(attr)?true:false
}
~~~
## js创建值的俩种方式
+ var ary={},字面量方式
+ var are=new ary 基于构造函数
不管哪种方式，都是object的实例。
## 原型和原型链
+ 所有的函数都带有一个属性prototype，是对象数据类型
+ prototype天生自带一个属性，constructor，指向当前的类（构造函数）；
+ 所有的对象（普通的对象，数组，prototype,constructor)都有一个属性__proto__，它指向所属类的原型
 ## 查找：先看自己私有的有没有，如果没有，基于__proto__,向上查找...直到找到object.prototype为止，如果说都没有，返回值就是undefined。（先看私有的，再看公有）这种查找机制就是原型链查找。